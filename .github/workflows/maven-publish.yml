# This workflow will build a package using Maven and then publish it to GitHub packages when a release is created
# For more information see: https://github.com/actions/setup-java/blob/main/docs/advanced-usage.md#apache-maven-with-a-settings-path

name: Maven Package

on:
  push:
  workflow_dispatch:
  #release:
    #types: [created]

permissions:
  contents: read
  id-token: write # <--- REQUIRED for OIDC

env:
  ARTIFACTORY_DEV_USER: ${{ secrets.ARTIFACTORY_DEV_USER }}
  ARTIFACTORY_DEV_KEY: ${{ secrets.ARTIFACTORY_DEV_KEY }}
  ARTIFACTORY_RELEASE_USER: ${{ secrets.ARTIFACTORY_RELEASE_USER }}
  ARTIFACTORY_RELEASE_KEY: ${{ secrets.ARTIFACTORY_RELEASE_KEY }}
  # Set defaults here or as repository/organization variables (recommended)
  AWS_REGION: us-east-1           # <- change to your region or set as repo variable
  AWS_ACCOUNT_ID: 850756192530      # <- change to your AWS account id or set as repo var
  ECR_REPOSITORY: dwp/np/blog            # <- change to your ECR repository name
  #ECR_PUSH_ROLE: ${{ secrets.AWS_ECR_NONPROD_PUSH_ROLE }}




jobs:
  maven:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    services:
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_DB: testdb
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
        options: >-
          --health-cmd "pg_isready -U testuser"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:

    - name: Setup Maven Action
      uses: s4u/setup-maven-action@v1.19.0
      with:
          java-version: 17
          java-distribution: 'temurin'
          maven-version: 3.9.11
          settings-servers: |
            [{
              "id": "myreleaserepo",
              "username": "${env.ARTIFACTORY_RELEASE_USER}",
              "password": "${env.ARTIFACTORY_RELEASE_KEY}"
            },
            {
              "id": "mysnapshotrepo",
              "username": "${env.ARTIFACTORY_DEV_USER}",
              "password": "${env.ARTIFACTORY_DEV_KEY}"
            }]

    - name: Build
      run: mvn clean package --file pom.xml -DskipTests -B
    
    - name: Upload build artifact (target/)
      uses: actions/upload-artifact@v4
      with:
        name: build-target
        # upload whole target directory. Use a glob if you prefer only jar files (target/*.jar)
        path: target

    - name: Wait for Postgres to be ready
      run: |
          # Service container is reachable at localhost:5432 on GitHub-hosted runner
          for i in $(seq 1 30); do
            pg_isready -h localhost -p 5432 -U testuser && break
            echo "Waiting for postgres..."
            sleep 2
          done
      env:
        PGPASSWORD: testpass

    - name: Test
      run: mvn clean test -P citestcase -Ddb.url=$dburl -Ddb.username=$dbuser -Ddb.password=$dbpass
      env:
        dburl: "jdbc:postgresql://localhost:5432/testdb?serverTimezone=UTC"
        dbuser: testuser
        dbpass: testpass
    
    #- name: Publish
      #run: mvn clean deploy --file pom.xml -DskipTests -B


  docker:
    runs-on: ubuntu-latest
    needs: maven
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ECR_NONPROD_PUSH_ROLE }}  # or use a secret: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActionsECR
          aws-region: ${{ env.AWS_REGION }}
      
      # - name: Configure AWS Credentials
      #   uses: aws-actions/configure-aws-credentials@v5
      #   with:
      #     aws-region: ${{ env.AWS_REGION }}
      #     role-session-name: GitHubActionsECR
      #     role-to-assume: ${{ secrets.AWS_ADMIN_ROLE }}


      #- name: Ensure ECR repository exists
      #  run: |
      #    aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" >/dev/null 2>&1 || \
      #      aws ecr create-repository --repository-name "${{ env.ECR_REPOSITORY }}"
        # This uses the temporary credentials from configure-aws-credentials.

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        # amazon-ecr-login uses current AWS credentials and logs docker to ECR

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download build artifact (target/)
        uses: actions/download-artifact@v4
        with:
          name: build-target
          path: ./   # downloads artifact contents into the runner workspace (creates ./target)

      - name: Show downloaded files
        run: |
          echo "PWD: $(pwd)"
          ls -la
          ls -la target || true

      # Optional: ensure the artifact exists before docker build
      - name: Fail if artifact missing
        run: |
          if [ ! -d "target" ]; then
            echo "target directory not found. Aborting."
            exit 1
          fi

      - name: Build and push to ECR
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          # Tags: both 'latest' and a commit-specific digest tag
          tags: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest,${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          # Optional: use GitHub Actions cache for build layers (fast incremental builds)
          cache-from: type=gha
          cache-to: type=gha,mode=max
